#!/usr/bin/env python

"""
(c) 2019 Network To Code

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import argparse
import sys
import os
import json
import yaml
import logging
import random  # noqa: F401
import pdb
import re

from collections import defaultdict

from pybatfish.client.commands import *

# noinspection PyUnresolvedReferences
from pybatfish.datamodel import Edge, Interface
from pybatfish.client.session import Session
from pybatfish.datamodel.flow import HeaderConstraints, PathConstraints  # noqa: F401
from pybatfish.question import bfq, list_questions, load_questions  # noqa: F401

from termcolor import colored

import pynetbox
import requests

from nornir import InitNornir

import network_importer
import network_importer.config as config

from network_importer.model import (
    NetworkImporterDevice,
    NetworkImporterInterface,
    NetworkImporterSite,
    NetworkImporterVlan,
)

from jinja2 import Template, Environment, FileSystemLoader


__author__ = "Damien Garros <damien.garros@networktocode.com>"

logger = logging.getLogger("network-importer")

PRESENT = colored("PRESENT", "green")
ABSENT = colored("ABSENT", "yellow")

class CustomFormatter(
    argparse.RawDescriptionHelpFormatter, argparse.ArgumentDefaultsHelpFormatter
):
    pass


def parse_args(args=sys.argv[1:]):
    """Parse arguments."""
    parser = argparse.ArgumentParser(
        description=sys.modules[__name__].__doc__, formatter_class=CustomFormatter
    )

    parser.add_argument(
        "--config",
        type=str,
        help="Network Importer Configuration file (TOML format)",
        default="network_importer.toml",
    )

    parser.add_argument(
        "--configs",
        metavar="DIR",
        type=str,
        help="Directory where to find the network configurations (in batfish format)",
        default=False,
    )

    parser.add_argument(
        "--output",
        metavar="DIR",
        type=str,
        help="Directory where to save the device variables",
        default="host_vars",
    )

    parser.add_argument(
        "--limit", type=str, help="limit the execution on a specific device"
    )

    parser.add_argument(
        "--debug",
        action="store_true",
        default=False,
        help="Keep the script in interactive mode once finished for troubleshooting",
    )

    parser.add_argument("--inventory", help="Inventory file", type=str, default=False)

    g = parser.add_mutually_exclusive_group(required=True)
    g.add_argument(
        "--check",
        action="store_true",
        default=False,
        help="Display what are the differences but do not save them",
    )

    g.add_argument(
        "--apply", action="store_true", default=False, help="Save changes in Backend"
    )

    return parser.parse_args(args)

find_digit = re.compile("\D?(\d+)\D?")
def sort_by_digits(if_name):
    return tuple(map(int, find_digit.findall(if_name)))


def jinja_filter_toyaml_list(value):
    return yaml.dump(value, default_flow_style=None)


def jinja_filter_toyaml_dict(value):
    return yaml.dump(value, default_flow_style=False)


def initialize_devices(task):

    nb = pynetbox.api(config.netbox.get("address"), token=config.netbox.get("token"))

    # TODO add check to ensure device is present
    # Also only pull the cache if the object exist already
    nb_dev = nb.dcim.devices.get(name=task.host.name)

    dev = NetworkImporterDevice(
        name=task.host.name, nb=nb, pull_cache=True
    )

    logger.info(f"Initializing Device {dev.name} .. ")

    if nb_dev:
        dev.remote = nb_dev
        dev.exist_remote = True

    return dev


def main():

    module_path = os.path.dirname(network_importer.__file__)
    TPL_DIR = f"{module_path}/templates/"

    options = parse_args()

    config.load_config(options.config)

    # ------------------------------------------------------------
    # Setup Logging
    # ------------------------------------------------------------
    logging.getLogger("pybatfish").setLevel(logging.ERROR)
    logging.basicConfig(stream=sys.stdout)

    logger.setLevel(logging.INFO)

    # ------------------------------------------------------------
    # Initialize Batfish (TODO If configs have been provided)
    # ------------------------------------------------------------
    CURRENT_DIRECTORY = os.getcwd().split("/")[-1]
    NETWORK_NAME = f"network-importer-{CURRENT_DIRECTORY}"
    SNAPSHOT_NAME = "network-importer"
    SNAPSHOT_PATH = options.configs

    bf_session.host = BATFISH_ADDR

    try:
        load_questions()
    except requests.exceptions.ConnectionError:
        logger.critical(
            f"Unable to connect to the batfish service ({BATFISH_ADDR}) .. please check if it's running"
        )
        sys.exit(1)

    logger.info("Importing and analyzing all configurations ... ")

    bf_set_network(NETWORK_NAME)
    bf_init_snapshot(SNAPSHOT_PATH, name=SNAPSHOT_NAME, overwrite=True)

    batfish_session = Session()
    batfish_session.set_network(NETWORK_NAME)
    batfish_session.set_snapshot(SNAPSHOT_NAME)

    # ------------------------------------------------------------
    # Initialize Netbox and check if all parameters are correct
    # ------------------------------------------------------------
    nb = pynetbox.api(config.netbox["address"], token=config.netbox["token"])
    try:
        nb.dcim.devices.get(name="notpresent")
    except requests.exceptions.ConnectionError:
        logger.critical(
            "Unable to connect to the netbox server, please check the NETBOX_ADDRESS env variable"
        )
        sys.exit(1)
    except pynetbox.core.query.RequestError as e:
        print(e)
        logger.critical(
            "Unable to complete a query to the netbox server, please check the env variables"
        )
        sys.exit(1)
    except requests.exceptions.RequestException as e:
        logger.critical(
            "Unable to connect to the netbox server, please check the address and the token"
        )
        print(e)
        sys.exit(1)

    # ------------------------------------------------------------
    # Build Inventories
    # ------------------------------------------------------------
    # TODO manage exception for Nornir and the validity of the inventory file
    if options.inventory:
        nr = InitNornir(
            core={"num_workers": 2},
            logging={"enabled": False},
            inventory={
                "plugin": "nornir.plugins.inventory.ansible.AnsibleInventory",
                "options": {"hostsfile": options.inventory},
            },
        )

    # If Batfish is the primary source of information
    nrt = InitNornir( 
            core={"num_workers": 2},
            logging={"enabled": False},
            inventory={
                "plugin": "network_importer.inventory.NornirInventoryFromBatfish",
                "options": {"devices": bfq.nodeProperties().answer().frame() }
            },
        )

    sites = dict()
    devs = dict()

    # ------------------------------------------------------------
    # Build inventory
    #  - if only batfish
    #      devices are expected to exist in netbox already
    #      Fail if device is not present
    #  - if Nornir and Batfish
    #      if the device is not present in netbox,
    #          check if site, model and role info are present
    #          try to create the device
    #      check if the site is defined in nornir
    #
    #  - If only Nornir
    #     Not supported Yet
    # ------------------------------------------------------------
    results = nrt.run(task=initialize_devices)

    for dev_name, items in results.items():
        if items[0].failed:
            logger.warning(f"Something went wrong while trying to pull the device information for {dev_name}")
            continue

        dev = items[0].result
        
        # TODO convert this action to a function to be able to properly extract
        dev.bf = bfq.nodeProperties(nodes=dev.name).answer().frame().loc[0 , : ]
        devs[dev_name] = dev

    # TODO Add check to only create directory if required
    if options.apply and not os.path.exists(options.output) and config.main["generate_hostvars"]:
        os.makedirs(options.output)
        logger.debug(f"Directory {options.output} was missing, created it")

    # Initialize the site information
    for dev in devs.values():

        if not dev.exist_remote:
            continue

        ## Check if site and vlans information are already in cache
        if dev.remote.site.slug not in sites.keys():
            site = NetworkImporterSite(name=dev.remote.site.slug, nb=nb)
            sites[site.name] = site
            dev.site = site
            logger.debug(f"Created site {site.name}")

        else:
            dev.site = sites[dev.remote.site.slug]


    # ----------------------------------------------------------------------
    # For each device, process the list of interfaces / Ips from batfish
    # ----------------------------------------------------------------------
    for dev in devs.values():
    
        logger.info(f"Processing {dev.name} data, local and remote .. ")

        bf_ints = bfq.interfaceProperties(nodes=dev.name).answer()

        for bf_intf in bf_ints.frame().itertuples():
            found_intf = False

            intf_name = bf_intf.Interface.interface

            intf = NetworkImporterInterface(
                name=intf_name,
                device_name=dev.name
            )

            intf.add_bf_intf(bf_intf)
            dev.add_interface(intf)

            if config.main["import_ips"]:
                for prfx in bf_intf.All_Prefixes:
                    dev.add_ip(intf_name=intf.name, address=prfx)

            bf_vlans = bfq.switchedVlanProperties(nodes=dev.name).answer()
            for vlan in bf_vlans.frame().itertuples():
                if vlan.VLAN_ID not in dev.site.vlans.keys():
                    dev.site.add_vlan(
                        NetworkImporterVlan(
                            name=f"vlan-{vlan.VLAN_ID}", vid=vlan.VLAN_ID
                        )
                    )

        if options.apply and config.main["generate_hostvars"]:

            # Save device variables in file
            if not os.path.exists(f"{options.output}/{dev.name}"):
                os.makedirs(f"{options.output}/{dev.name}")
                logger.debug(
                    f"Directory {options.output}/{dev.name} was missing, created it"
                )

            dev_facts = batfish_session.extract_facts(nodes=dev.name)["nodes"][dev.name]
            del dev_facts["Interfaces"]

            # pdb.set_trace()
            # Load Jinja2 template
            # env = Environment(
            #     loader=FileSystemLoader(TPL_DIR), trim_blocks=True, lstrip_blocks=True
            # )
            # env.filters["to_yaml_list"] = jinja_filter_toyaml_list
            # env.filters["to_yaml_dict"] = jinja_filter_toyaml_dict
            # template = env.get_template("hostvars.j2")
            # hostvars_str = template.render(dev_facts)

            with open(
                f"{options.output}/{dev.name}/network_importer.yaml", "w"
            ) as out_file:
                out_file.write( yaml.dump(dev_facts, default_flow_style=False))
                # out_file.write( hostvars_str)
                logger.debug(
                    f"{dev.name} - Host variables saved in {options.output}/{dev.name}/network_importer.yaml"
                )

    # ------------------------------------------------------------------------------------
    # Update Remote if apply is enabled
    #   First create all vlans per site to ensure they exist
    # ------------------------------------------------------------------------------------
    if options.apply:
        for site in sites.values():
            site.update_remote()

        for dev in devs.values():
            dev.update_remote()

    # ------------------------------------------------------------------------------------
    # Print on Screen all devices, interfaces and IPs and how their current status compare to remote
    #   Currently we only track PRESENT and ABSENT but we should also track DIFF and UPDATED
    #   This print function might be better off in the device object ...
    # ------------------------------------------------------------------------------------
    for site in sites.values():
        print(f" -- Site {site.name} -- ")
        for vlan in site.vlans.values():
            if vlan.exist_remote:
                print("{:4}{:32}{:12}".format("", f"Vlan {vlan.vid}", PRESENT))
            else:
                print("{:4}{:32}{:12}".format("", f"Vlan {vlan.vid}", ABSENT))

        print("  ")

        for dev in devs.values():
            if dev.site.name != site.name:
                continue
            if dev.exist_remote:
                print("{:4}{:42}{:12}".format("", f"Device {dev.name}", PRESENT))
            else:
                print("{:4}{:42}{:12}".format("", f"Device {dev.name}", ABSENT))

            for intf_name in sorted(dev.interfaces.keys(), key=sort_by_digits):
                intf = dev.interfaces[intf_name]
                if intf.exist_remote:
                    print("{:8}{:38}{:12}".format("", f"{intf.name}", PRESENT))
                else:
                    print("{:8}{:38}{:12}".format("", f"{intf.name}", ABSENT))

                for ip in intf.ips.values():
                    if ip.exist_remote:
                        print("{:12}{:34}{:12}".format("", f"{ip.address}", PRESENT))
                    else:
                        print("{:12}{:34}{:12}".format("", f"{ip.address}", ABSENT))
            print("  ")

    # -------------------------------------------------------------
    # Build cabling
    #   Currently we are only getting the information from the L3 EDGE in Batfish
    #   We need to pull LLDP data as well using Nornir to complement that
    # -------------------------------------------------------------

    p2p_links = bfq.layer3Edges().answer()
    already_connected_links = {}

    for link in p2p_links.frame().itertuples():
        try:
            local_host = link.Interface.hostname
            local_intf = re.sub("\.\d+$", "", link.Interface.interface)
            remote_host = link.Remote_Interface.hostname
            remote_intf = re.sub("\.\d+$", "", link.Remote_Interface.interface)

            unique_id = "_".join(
                sorted([f"{local_host}:{local_intf}", f"{remote_host}:{remote_intf}"])
            )
            if unique_id in already_connected_links:
                logger.debug(f"Link {unique_id} already connected .. SKIPPING")
                continue

            if local_host not in devs.keys():
                logger.debug(f"LINK: {local_host} not present in devices list")
                continue
            elif remote_host not in devs.keys():
                logger.debug(f"LINK: {remote_host} not present in devices list")
                continue

            if local_intf not in devs[local_host].interfaces.keys():
                logger.warning(
                    f"LINK: {local_host}:{local_intf} not present in interfaces list"
                )
                continue
            elif remote_intf not in devs[remote_host].interfaces.keys():
                logger.warning(
                    f"LINK: {remote_host}:{remote_intf} not present in interfaces list"
                )
                continue

            if devs[local_host].interfaces[local_intf].is_virtual :
                logger.debug(
                    f"LINK: {local_host}:{local_intf} is a virtual interface, can't be used for cabling SKIPPING"
                )
                continue
            elif devs[remote_host].interfaces[remote_intf].is_virtual:
                logger.debug(
                    f"LINK: {remote_host}:{remote_intf} is a virtual interface, can't be used for cabling SKIPPING"
                )
                continue

            if not devs[local_host].interfaces[local_intf].remote:
                logger.warning(
                    f"LINK: {local_host}:{local_intf} remote object not present SKIPPING"
                )
                continue
            elif not devs[remote_host].interfaces[remote_intf].remote:
                logger.warning(
                    f"LINK: {remote_host}:{remote_intf} remote object not present SKIPPING"
                )
                continue

            

            ## Check if both interfaces are already connected or not

            if devs[local_host].interfaces[local_intf].remote.connection_status:
                remote_host_reported = (
                    devs[local_host]
                    .interfaces[local_intf]
                    .remote.connected_endpoint.device.name
                )
                remote_int_reported = (
                    devs[local_host]
                    .interfaces[local_intf]
                    .remote.connected_endpoint.name
                )

                if remote_host_reported != remote_host:
                    logger.warning(
                        f"LINK: {local_host}:{local_intf} is already connected but to a different device ({remote_host_reported} vs {remote_host})"
                    )
                elif (
                    remote_host_reported == remote_host
                    and remote_intf != remote_int_reported
                ):
                    logger.warning(
                        f"LINK: {local_host}:{local_intf} is already connected but to a different interface ({remote_int_reported} vs {remote_intf})"
                    )

                continue

            elif devs[remote_host].interfaces[remote_intf].remote.connection_status:
                local_host_reported = (
                    devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.connected_endpoint.device.name
                )
                local_int_reported = (
                    devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.connected_endpoint.name
                )

                if local_host_reported != local_host:
                    logger.warning(
                        f"LINK: {remote_host}:{remote_intf} is already connected but to a different device ({local_host_reported} vs {local_host})"
                    )
                elif (
                    local_host_reported == local_host
                    and local_intf != local_int_reported
                ):
                    logger.warning(
                        f"LINK:  {remote_host}:{remote_intf} is already connected but to a different interface ({local_int_reported} vs {local_intf})"
                    )

                continue

            else:
                logger.info(
                    f"Link not present will create it in netbox ({local_host}:{local_intf} || {remote_host}:{remote_intf}) "
                )
                link = nb.dcim.cables.create(
                    termination_a_type="dcim.interface",
                    termination_a_id=devs[local_host].interfaces[local_intf].remote.id,
                    termination_b_type="dcim.interface",
                    termination_b_id=devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.id,
                )

                already_connected_links[unique_id] = 1
        except:
            logger.warning(
                f"Something went wrong while processing the link {unique_id}",
                exc_info=True,
            )

    if options.debug:
        pdb.set_trace()

if __name__ == "__main__":
    main()
